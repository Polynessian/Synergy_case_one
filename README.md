# Synergy_case_one
Алгоритм для учебной практики на двух языках программирования

Описание объектных моделей алгоритма

Основа строения модели алгоритма - класс FindElement, который имеет два метода:

    1) find_positive_sum (Python), findSumOfPositiveElements (JS), в JavaScript имеется также геттер, который вызывает данный
    метод.

        Описание: 
             Если массив А не пуст, определяется переменная positive_data(в файле JS - positiveData), массив, который запол-
            няется элементами массива А, большими, чем 0.

             Первым ответом будет длина массива positive_data(в файле JS - positiveData) и сумма элементов в нем.

    2) sort_by_B (Python), countSumOfElemFromB(JS), также геттерБ вызывающий этот метод.

        Описание:
             Определяется переменная Array_B(Python), arrayB(JS), массив который является отсортированной по возрастанию копией
            массива А. Определяется переменая ElementB(Python), elementB, которая будет точкой отсчета для среза массива ArrayB.

             Проводится проверка элементов массива на одинаковость, если все элементы совпадут с числом B, ответом будет строка 
            'Элементов, больше заданного числа B в массиве нет, все элементы равны' или 'Все числа в массиве одинаковые'.

             Определяется индекс элемента, с которого начнется срез чисел из списка, больших заданного числа B(ElementB).
            В цикле по массиву Array_B(arrayB) задается условие:
             Если переменная цикла el больше ElementB(elementB), то цикл прерывается и ElementB(elementB) присваивается значение
            переменной цикла el.
             Если не выполняется первая часть условия, и el не является последним элементом, цикл продолжается с помощью
            оператора continue.
             Если ни одно из вышеуказанных частей условия не выполнено, цикл заканчивается исключением
            'Элементов, больше заданного числа B в массиве нет'.

             Переменной splice_array_B(spliceArrayB - JS) присваивается срез массива Array_B, начиная с ElementB(elementB).

             Чтобы корректно подсчитать произведение элементов, больших числа B, задается условие в инверсии
            'Если 0 не в массиве splice_array_B(spliceArrayB)'
             В первой части условия отрабатывется случай, когда в срезе находится только один элемент, тогда произведение элем-
            ентов будет равно этому элементу.
             Далее, если количество элементов в срезе не равно 1, запускается цикл по splice_array_B(spliceArrayB), в котором
            определенная ранее переменая result(multRes),равная 1, каждую итерацию перемножается с переменной цикла s.
             Если среди множителей есть 0, в переменной result(multRes) будет храниться строка '0, т.к. один или несколько множит-
            елей являются нулевыми элементами'.

            Вторым ответом будет длина среза splice_array_B(spliceArrayB) и значение переменной result(multRes).

 В комментариях указаны значения A, B, N для отработки различных вариантов данных, по дефолту в JS файле установлено случайное 
заполнение числами массива А и случайные значенения размерности массива N и числа B. В Python файле по дефолту стоит пользователь-
ский ввод данных, в комментариях также указаны данные для отработки различных случаев и блок для случайного заполнения переменных
A, B и N. 

             
             
